#!/usr/bin/env python

import argparse
import sys
import pyc_parser
import pyc_sir
import pyc_asm_list
import pyc_var_analyzer
import pyc_reg_allocator
import pyc_asm_nodes
import pyc_ir
import pyc_localize
import pyc_heapify
import pyc_closure
import pyc_sir_to_py
import pyc_declassify
import pyc_lineage

import compiler
from pyc_log import *
import os.path
import time
import resource

g_phases = (
	("parse", 			pyc_parser),
	("declassify", 		pyc_declassify), 
	("localize", 		pyc_localize),
	("explicate",		pyc_ir),
	("heapify",			pyc_heapify),
	("closure",			pyc_closure),
	("sir-list",		pyc_sir),
	("asm-node-list",	pyc_asm_list)
)

g_allocs = [
	"sudoku",
	"stack"
]

def opt_parser():
	global g_phases

	parser = argparse.ArgumentParser(description='compile python to x86 assembly.')
	parser.add_argument('file', nargs='?', type=argparse.FileType('r'), help='file to compile')
	parser.add_argument('-c', '--code', help='code to compile')
	parser.add_argument('-o', '--output', help='output file.')
	parser.add_argument('-v', '--verbose', action='store_true', help='print debug output.')
	parser.add_argument(
		'-p', 
		'--phase', 
		help=('stop and print intermediate compiler result. phases: %s' % ", ".join(zip(*g_phases)[0])) 
	)
	parser.add_argument(
		'-i', 
		'--IR', 
		action='store_true', 
		help='output intermediate representation python program instead of x86'
	)
	parser.add_argument(
		'--alloc', 
		help=('choose register allocator algorithm (default: %s). algos: %s' % (g_allocs[0], ", ".join(g_allocs)) ) 
	)
	return parser


class MissingOption(Exception):
	pass


def validate(options):
	if options.file == None and options.code == None:
		raise MissingOption('specify either file or code to compile')		


def run(options):
	global g_phases
	#print options
	validate(options)

	if options.verbose == True:
		log_set_verbose()
	else:
		log_set_quiet()

	options.src_type = 'cmdline'
	options.src = options.code
	if options.src == None:
		options.src = options.file.read()
		options.src_type = 'file'

	if isinstance(options.src, basestring) != True:
		raise Exception('invalid src variable. type: %s' % (options.src.__class__.__name__) )

	if (not options.phase is None) and options.phase not in zip(*g_phases)[0]:
		raise Exception('invalid phase variable: %s' % options.phase)

	log(options)

	# Increase max stack size from 8MB to 512MB
	resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
	sys.setrecursionlimit(10**6)

	trace = pyc_lineage.Tracer()

	iast = pyc_parser.parse(options.src)
	if options.phase == 'parse':
		pyc_parser.print_astree(iast)
		exit(0)

	for (phase_name, phase_mod) in g_phases[1:-2]:
		log("phase: %s" % phase_name)
		iast = getattr(phase_mod, 'txform')(iast, tracer=trace)
		if options.phase == phase_name:
			pyc_parser.print_astree(iast)
			exit(0)
		
	sir_mod = pyc_sir.txform(iast, tracer=trace)
	if options.phase == 'sir-list':
		print pyc_sir.sir_list_to_str(sir_mod.body)
		exit(0)

	if options.IR:
		with output_file(options, "python") as f:
			print >>f, "import sys"
			print >>f, "sys.path.append(%s)" % repr(os.path.abspath("./pylib"))
			print >>f, "sys.path.append(%s)" % repr(os.path.abspath("./."))
			print >>f, "from pyc_runtime import *"
			pyc_sir_to_py.generate(sir_mod, f)	
			print >>f, ""
			print >>f, "#" + "*"*40 + "#"
			print >>f, "exit(main())"
		exit(0)
	
	bloc_list = pyc_asm_list.from_sir_mod(sir_mod)

	bloc_list_str = lambda : "\n".join([repr(n) for n in bloc_list])
	if options.phase == 'asm-node-list':
		print bloc_list_str()
		exit(0)

	flat_bloc_list = []
	for bloc in bloc_list:
		t0 = time.time()
		(adjusted_insns, symtbl) = pyc_reg_allocator.allocate(bloc.insns, options.alloc == 'stack')
		#print "allocation time: %d" % (time.time() - t0)
	
		asm_ir = pyc_asm_nodes.AsmIf.patch(adjusted_insns)

		log(lambda : "final bloc: %r" % bloc )
		flat_bloc_list.append(pyc_asm_nodes.FlatCodeBloc(
			name = bloc.name,
			insns = asm_ir,
			symtbl = symtbl
		))

	output(options, flat_bloc_list)


def asm_headers():
	headers = []
	headers.extend(pyc_asm_nodes.GlobalString.data_headers())
	headers.extend([
		".text",
	])

	return headers

def asm_trailers():
	return [
		".globl  start",
		".type   start, @function",
		"start:",
		"\tpushl   %ebp",
		"\tmovl    %esp, %ebp",
		"\tcall    main",
		"\tmovl    $0, %eax",
		"\tleave",
		"\tret"
	]

def output_is_to_stdout(options):
	return (options.src_type == 'cmdline' or options.output == '-')

def output_file(options, type):
	if output_is_to_stdout(options):
		return sys.stdout
	else:
		ext = "py-ir" if type == "python" else "s"
		output_fname = "%s.%s" % (os.path.splitext(options.file.name)[0], ext)
		ofile = open(output_fname, 'w')
		return ofile
	
	
def with_output_file(options, type, bloc):
	ofile = output_file(options, type)

	bloc(ofile)

	ofile.flush()
	if ofile != sys.stdout:
		ofile.close()
	
	
def output(options, flat_bloc_list):
	with output_file(options, "asm") as f:
		for hdr in asm_headers():
			print >>f, (hdr)

		print >>f
		for bloc in flat_bloc_list:
			print >>f
			print >>f, ".globl  %s" % bloc.name
			print >>f, "%s:" % bloc.name
			bloc.to_asm(f, lambda s: ("\t" + s))
		
		print >>f
		for trlr in asm_trailers():
			print >>f, trlr

if __name__ == "__main__":
	opt_p = opt_parser()
	options = opt_p.parse_args()

	try:
		run(options)
	except MissingOption as e:
		print e
		print
		opt_p.print_help()
		exit(-1)

