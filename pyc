#!/usr/bin/env python

import argparse
import sys
import pyc_ast
import pyc_asm_list
import pyc_var_analyzer
import pyc_reg_allocator
import pyc_asm_nodes
import pyc_ir
import pyc_localize
import pyc_heapify
import pyc_closure
import pyc_sir_to_py

import compiler
from pyc_log import *
import os.path
import time
import resource

g_phases = [
	"parse", 
	"localize", 
	"explicate", 
	"heapify", 
	"closure",
	"sir-list", 
	"asm-node-list"
]

def opt_parser():
	global g_phases

	parser = argparse.ArgumentParser(description='compile python to x86 assembly.')
	parser.add_argument('file', nargs='?', type=argparse.FileType('r'), help='file to compile')
	parser.add_argument('-c', '--code', help='code to compile')
	parser.add_argument('-o', '--output', help='output file.')
	parser.add_argument('-v', '--verbose', action='store_true', help='print debug output.')
	parser.add_argument(
		'-p', 
		'--phase', 
		help=('stop and print intermediate compiler result. phases: %s' % ", ".join(g_phases)) 
	)
	parser.add_argument(
		'-i', 
		'--IR', 
		action='store_true', 
		help='output intermediate representation python program instead of x86'
	)

	return parser


class MissingOption(Exception):
	pass


def validate(options):
	if options.file == None and options.code == None:
		raise MissingOption('specify either file or code to compile')		


def run(options):
	global g_phases
	#print options
	validate(options)

	if options.verbose == True:
		log_set_verbose()
	else:
		log_set_quiet()

	options.src_type = 'cmdline'
	options.src = options.code
	if options.src == None:
		options.src = options.file.read()
		options.src_type = 'file'

	if isinstance(options.src, basestring) != True:
		raise Exception('invalid src variable. type: %s' % (options.src.__class__.__name__) )

	if (not options.phase is None) and options.phase not in g_phases:
		raise Exception('invalid phase variable: %s' % options.phase)

	log(options)
	#import parser only now because we want to know if
	#we are verbose or not first.
	import pyc_parser

	# Increase max stack size from 8MB to 512MB
	resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
	sys.setrecursionlimit(10**6)

	t0 = time.time()
	as_tree1 = pyc_parser.parse(options.src)
	if options.phase == 'parse':
		pyc_parser.print_astree(as_tree1)
		exit(0)

	log( lambda : pyc_parser.tree_to_str(as_tree1))
	#print "parse time: %d" % (time.time() - t0)

	as_tree2 = pyc_localize.txform(as_tree1)
	if options.phase == 'localize':
		pyc_parser.print_astree(as_tree2)
		exit(0)

	t0 = time.time()
	ir_tree = pyc_ir.generate(as_tree2)
	if options.phase == 'explicate':
		pyc_ir.print_irtree(ir_tree)
		exit(0)
	
	#print "explicate time: %d" % (time.time() - t0)	

	heapified_ir_tree = pyc_heapify.txform(ir_tree)
	if options.phase == 'heapify':
		pyc_ir.print_irtree(heapified_ir_tree)
		#print pyc_parser.dump(heapified_ir_tree)
		exit(0)

	converted_ir_tree = pyc_closure.convert(heapified_ir_tree)
	if options.phase == 'closure':
		pyc_ir.print_irtree(converted_ir_tree)
		exit(0)
		
	t0 = time.time()
	sir_mod = pyc_ast.simple_ir(converted_ir_tree)
	if options.phase == 'sir-list':
		print pyc_ast.sir_list_to_str(sir_mod.body)
		pyc_sir_to_py.generate(sir_mod, sys.stdout)
		exit(0)

	log("sir list: ")
	log(lambda : pyc_ast.sir_list_to_str(sir_mod.body) )
	
	if options.IR:
		#with output_file(options, "python") as f:
		#	for stmt in sir_mod.body:
		#		print >>f, pyc_ir.to_py(stmt)
		raise Exception("not implemented")
		exit(0)

	
	#print "flatten time: %d" % (time.time() - t0) 
	
	t0 = time.time()
	asm_list = pyc_asm_list.from_sir_mod(sir_mod)

	asm_list_str = lambda : "\n".join([repr(n) for n in asm_list])
	if options.phase == 'asm-node-list':
		print asm_list_str()
		exit(0)

	log(asm_list_str)	
	#print "instruction selection time: %d" % (time.time() - t0)

	t0 = time.time()
	(adjusted_asm_list, symtbl) = pyc_reg_allocator.allocate(asm_list)
	#print "allocation time: %d" % (time.time() - t0)

	t0 = time.time()
	asm_ir_list = pyc_asm_nodes.AsmIf.patch(adjusted_asm_list)

	insns = []
	insns.extend(asm_prefix())

	stacksize = symtbl.stack()
	align = 16
	if stacksize > 0:
		insns.append("subl\t$%s, %%esp" % (stacksize + (align - (stacksize % align))) )

	insns.extend(format_insn_nodes(asm_ir_list, sir_mod, symtbl) )
	insns.extend(asm_suffix())

	output(options, insns)
	#print "output time: %d" % (time.time() - t0)

def format_insn_nodes(ins_nodes, sir_mod, symtbl):
	result = []
	previous = None
	
	for ins in ins_nodes:
		if not isinstance(ins, pyc_asm_nodes.Inst):
			raise Exception("expected instruction node")

		patched = pyc_reg_allocator.patch_insn(ins, symtbl)
		
		if patched.is_noop():
			continue
		
		s = str(patched)
		#if previous is None or previous.origin != ins.origin:
		#	origin_s = repr(None) if ins.origin is None else pyc_ir.dump(ins.origin)
		#	s = "%-20s #%s" % (s, origin_s)
	
		previous = ins
		result.append(s)

	return result

def asm_headers():
	headers = []
	headers.extend(pyc_asm_nodes.GlobalString.data_headers())
	headers.extend([
		".text",
		".globl  main",
		".type   main, @function",
		"main:"
	])

	return headers


def asm_prefix():
	return [
		"pushl   %ebp",
		"movl    %esp, %ebp"
	]

def asm_suffix():
	return [
		"movl    $0, %eax",
		"leave",
		"ret"
	]

def output_is_to_stdout(options):
	return (options.src_type == 'cmdline' or options.output == '-')

def output_file(options, type):
	if output_is_to_stdout(options):
		return sys.stdout
	else:
		ext = "py" if type == "python" else "s"
		output_fname = "%s.%s" % (os.path.splitext(options.file.name)[0], ext)
		ofile = open(output_fname, 'w')
		return ofile
	
	
def with_output_file(options, type, bloc):
	ofile = output_file(options, type)

	bloc(ofile)

	ofile.flush()
	if ofile != sys.stdout:
		ofile.close()

	
	
def output(options, insns):
	with output_file(options, "asm") as f:
		for hdr in asm_headers():
			print >>f, (hdr)
		for ins in insns:
			print >>f, ("\t" + ins)
			
	

if __name__ == "__main__":
	opt_p = opt_parser()
	options = opt_p.parse_args()

	try:
		run(options)
	except MissingOption as e:
		print e
		print
		opt_p.print_help()
		exit(-1)

