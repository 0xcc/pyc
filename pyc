#!/usr/bin/env python

import argparse
import sys
import pyc_ast
import pyc_asm_list
import pyc_var_analyzer
import pyc_reg_allocator
import pyc_asm_nodes
import pyc_ir
import pyc_localize
import pyc_heapify
import pyc_closure
import pyc_sir_to_py
import pyc_declassify

import compiler
from pyc_log import *
import os.path
import time
import resource

g_phases = [
	"parse",
	"declassify", 
	"localize", 
	"explicate", 
	"heapify", 
	"closure",
	"sir-list", 
	"asm-node-list"
]

g_allocs = [
	"sudoku",
	"stack"
]

def opt_parser():
	global g_phases

	parser = argparse.ArgumentParser(description='compile python to x86 assembly.')
	parser.add_argument('file', nargs='?', type=argparse.FileType('r'), help='file to compile')
	parser.add_argument('-c', '--code', help='code to compile')
	parser.add_argument('-o', '--output', help='output file.')
	parser.add_argument('-v', '--verbose', action='store_true', help='print debug output.')
	parser.add_argument(
		'-p', 
		'--phase', 
		help=('stop and print intermediate compiler result. phases: %s' % ", ".join(g_phases)) 
	)
	parser.add_argument(
		'-i', 
		'--IR', 
		action='store_true', 
		help='output intermediate representation python program instead of x86'
	)
	parser.add_argument(
		'--alloc', 
		help=('choose register allocator algorithm (default: %s). algos: %s' % (g_allocs[0], ", ".join(g_allocs)) ) 
	)
	return parser


class MissingOption(Exception):
	pass


def validate(options):
	if options.file == None and options.code == None:
		raise MissingOption('specify either file or code to compile')		


def run(options):
	global g_phases
	#print options
	validate(options)

	if options.verbose == True:
		log_set_verbose()
	else:
		log_set_quiet()

	options.src_type = 'cmdline'
	options.src = options.code
	if options.src == None:
		options.src = options.file.read()
		options.src_type = 'file'

	if isinstance(options.src, basestring) != True:
		raise Exception('invalid src variable. type: %s' % (options.src.__class__.__name__) )

	if (not options.phase is None) and options.phase not in g_phases:
		raise Exception('invalid phase variable: %s' % options.phase)

	log(options)
	#import parser only now because we want to know if
	#we are verbose or not first.
	import pyc_parser

	# Increase max stack size from 8MB to 512MB
	resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
	sys.setrecursionlimit(10**6)

	t0 = time.time()
	as_tree1 = pyc_parser.parse(options.src)
	if options.phase == 'parse':
		pyc_parser.print_astree(as_tree1)
		exit(0)

	log( lambda : pyc_parser.tree_to_str(as_tree1))
	#print "parse time: %d" % (time.time() - t0)

	as_tree_sans_class = pyc_declassify.txform(as_tree1)
	if options.phase == 'declassify':
		pyc_parser.print_astree(as_tree_sans_class)
		exit(0)

	as_tree2 = pyc_localize.txform(as_tree_sans_class)
	if options.phase == 'localize':
		pyc_parser.print_astree(as_tree2)
		exit(0)

	t0 = time.time()
	ir_tree = pyc_ir.generate(as_tree2)
	if options.phase == 'explicate':
		pyc_ir.print_irtree(ir_tree)
		exit(0)
	
	#print "explicate time: %d" % (time.time() - t0)	

	heapified_ir_tree = pyc_heapify.txform(ir_tree)
	if options.phase == 'heapify':
		pyc_ir.print_irtree(heapified_ir_tree)
		#print pyc_parser.dump(heapified_ir_tree)
		exit(0)

	converted_ir_tree = pyc_closure.convert(heapified_ir_tree)
	if options.phase == 'closure':
		pyc_ir.print_irtree(converted_ir_tree)
		exit(0)
		
	t0 = time.time()
	sir_mod = pyc_ast.simple_ir(converted_ir_tree)
	if options.phase == 'sir-list':
		print pyc_ast.sir_list_to_str(sir_mod.body)
		exit(0)

	log("sir list: ")
	log(lambda : pyc_ast.sir_list_to_str(sir_mod.body) )
	
	if options.IR:
		with output_file(options, "python") as f:
			print >>f, "import sys"
			print >>f, "sys.path.append(%s)" % repr(os.path.abspath("./pylib"))
			print >>f, "sys.path.append(%s)" % repr(os.path.abspath("./."))
			print >>f, "from pyc_runtime import *"
			pyc_sir_to_py.generate(sir_mod, f)	
			print >>f, ""
			print >>f, "#" + "*"*40 + "#"
			print >>f, "exit(main())"
		exit(0)
	
	#print "flatten time: %d" % (time.time() - t0) 
	
	t0 = time.time()
	bloc_list = pyc_asm_list.from_sir_mod(sir_mod)

	bloc_list_str = lambda : "\n".join([repr(n) for n in bloc_list])
	if options.phase == 'asm-node-list':
		print bloc_list_str()
		exit(0)

	log(bloc_list_str)	
	#print "instruction selection time: %d" % (time.time() - t0)

	flat_bloc_list = []
	for bloc in bloc_list:
		t0 = time.time()
		(adjusted_insns, symtbl) = pyc_reg_allocator.allocate(bloc.insns, options.alloc == 'stack')
		#print "allocation time: %d" % (time.time() - t0)
	
		asm_ir = pyc_asm_nodes.AsmIf.patch(adjusted_insns)

		log(lambda : "final bloc: %r" % bloc )
		flat_bloc_list.append(pyc_asm_nodes.FlatCodeBloc(
			name = bloc.name,
			insns = asm_ir,
			symtbl = symtbl
		))

	output(options, flat_bloc_list)
	#print "output time: %d" % (time.time() - t0)


def asm_headers():
	headers = []
	headers.extend(pyc_asm_nodes.GlobalString.data_headers())
	headers.extend([
		".text",
	])

	return headers

def asm_trailers():
	return [
		".globl  start",
		".type   start, @function",
		"start:",
		"\tpushl   %ebp",
		"\tmovl    %esp, %ebp",
		"\tcall    main",
		"\tmovl    $0, %eax",
		"\tleave",
		"\tret"
	]

def output_is_to_stdout(options):
	return (options.src_type == 'cmdline' or options.output == '-')

def output_file(options, type):
	if output_is_to_stdout(options):
		return sys.stdout
	else:
		ext = "py-ir" if type == "python" else "s"
		output_fname = "%s.%s" % (os.path.splitext(options.file.name)[0], ext)
		ofile = open(output_fname, 'w')
		return ofile
	
	
def with_output_file(options, type, bloc):
	ofile = output_file(options, type)

	bloc(ofile)

	ofile.flush()
	if ofile != sys.stdout:
		ofile.close()
	
	
def output(options, flat_bloc_list):
	with output_file(options, "asm") as f:
		for hdr in asm_headers():
			print >>f, (hdr)

		print >>f
		for bloc in flat_bloc_list:
			print >>f
			print >>f, ".globl  %s" % bloc.name
			print >>f, "%s:" % bloc.name
			bloc.to_asm(f, lambda s: ("\t" + s))
		
		print >>f
		for trlr in asm_trailers():
			print >>f, trlr

if __name__ == "__main__":
	opt_p = opt_parser()
	options = opt_p.parse_args()

	try:
		run(options)
	except MissingOption as e:
		print e
		print
		opt_p.print_help()
		exit(-1)

